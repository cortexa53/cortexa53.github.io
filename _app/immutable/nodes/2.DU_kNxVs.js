import{s as a,n as s}from"../chunks/C4pY3C6E.js";import{S as c,i as n,e as d,c as p,m as r,n as h,j as f,g as x}from"../chunks/BfQPO7_g.js";function g(i){let e,o=`<div class="center-feed-bar svelte-77x811"></div> <div class="center-feed svelte-77x811"><h1 class="svelte-77x811">cortexa53
            <hr style="margin-top:3px;"/></h1> <div class="center-feed-posts svelte-77x811"><h2 class="svelte-77x811">zipRev</h2> <p style="margin-top:0.5%;margin-bottom:2%;font-size:12px;" class="svelte-77x811">Haskell; functional programming (10.19.25)</p> <p class="svelte-77x811">A question- is it possible to reverse a functional list, then zip it with another list, in one pass?  In Haskell, a solution to this problem looks something like this:</p> <pre>zipRev = foldl f b
    where   b = const []
            f z x = \\case
                        [] -&gt; []
                        (y:ys) -&gt; (x,y) : z ys
            </pre> <p class="svelte-77x811">Note that this requires the <code>LambdaCase</code> extension.</p> <p class="svelte-77x811"> </p> <p class="svelte-77x811">The function is a pretty elegant application of <code>foldl</code>, but I don&#39;t think its implementation is intuitively obvious - which begs the question of how one might come up with it from scratch.</p> <p class="svelte-77x811"> </p> <p class="svelte-77x811">Defining <code>zip</code> in terms of <code>foldr</code> and some folding function <code>g</code> is a potentially fruitful start, 
            since <code>foldl (flip g)</code> can be loosely thought of as folding the first input list in &quot;reverse&quot;.</p> <p class="svelte-77x811"> </p> <p class="svelte-77x811"><code>zip = foldr g b</code> implies that <code>zip xs = foldr g b xs</code>.</p> <p class="svelte-77x811"> </p> <p class="svelte-77x811">Thus, <code>zip [] = b</code> by the definition of <code>foldr</code>, meaning that <code>b = \\ys -&gt; []</code> or <code>const []</code> based on the semantics of <code>zip</code>.</p> <p class="svelte-77x811"> </p> <p class="svelte-77x811">At the same time, <code>zip (x:xs) = g x (foldr g b xs)</code>, meaning that <code>zip (x:xs) ys = g x (foldr g b xs) ys</code>.</p> <p class="svelte-77x811"> </p> <p class="svelte-77x811">This tells us that our folding function <code>g</code> takes the head of <code>xs</code>, the result of folding its tail, and <code>ys</code> as arguments and returns a zipped list.  Remembering that
            folding its tail yields a function that zips its tail with whatever list you apply it to, we can straightforwardly define <code>g</code> as:</p> <pre>g x z = \\case
            [] -&gt; []
            (y:ys) -&gt; (x,y) : z ys
            </pre> <p class="svelte-77x811">Now, <code>foldl (flip g) b</code> builds up a thunk such that the outermost application of <code>flip g</code> is partially applied to the last element of <code>xs</code>, 
            before being applied to <code>ys</code>.  This is the behavior we want - the elements of <code>xs</code> are being paired up with the elements of <code>ys</code> in reverse order!</p> <p class="svelte-77x811"> </p> <p class="svelte-77x811">With this in mind, we can define <code>f = flip g</code> and <code>zipRev = foldl f b</code>.</p></div></div>`;return{c(){e=d("div"),e.innerHTML=o,this.h()},l(t){e=p(t,"DIV",{class:!0,"data-svelte-h":!0}),r(e)!=="svelte-1w7c48y"&&(e.innerHTML=o),this.h()},h(){h(e,"class","grid-container svelte-77x811")},m(t,l){f(t,e,l)},p:s,i:s,o:s,d(t){t&&x(e)}}}class u extends c{constructor(e){super(),n(this,e,null,g,a,{})}}export{u as component};

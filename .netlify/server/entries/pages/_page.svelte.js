import { c as create_ssr_component } from "../../chunks/ssr.js";
const css = {
  code: `@import url('https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@300..700&display=swap');@import url('https://fonts.googleapis.com/css2?family=Manrope:wght@200..800&display=swap');.grid-container.svelte-77x811.svelte-77x811{position:fixed;top:0;right:0;height:100vh;width:100vw;overflow:scroll;-webkit-overflow-scrolling:touch;display:grid;grid-template-columns:repeat(9, 1fr)}.center-feed.svelte-77x811.svelte-77x811{height:100%;grid-column-start:3;grid-column-end:8}.center-feed-bar.svelte-77x811.svelte-77x811{z-index:2;position:fixed;margin:0;padding:0;height:180px;width:100%;overflow:hidden;background:white}.center-feed.svelte-77x811 h1.svelte-77x811{font-family:"Space Grotesk", sans-serif;z-index:2;position:fixed;margin:0;top:130px}.center-feed-posts.svelte-77x811.svelte-77x811{position:relative;z-index:1;top:200px}.center-feed-posts.svelte-77x811 h2.svelte-77x811{margin:0;font-family:"Manrope", sans-serif}.center-feed-posts.svelte-77x811 p.svelte-77x811{font-family:"Manrope", sans-serif;margin:0}`,
  map: `{"version":3,"file":"+page.svelte","sources":["+page.svelte"],"sourcesContent":["<div class=\\"grid-container\\">\\n    <div class=\\"center-feed-bar\\">\\n    </div>\\n    <div class=\\"center-feed\\">\\n        <h1>brodal queue\\n            <hr style=\\"margin-top:3px;\\">\\n        </h1>\\n        <div class=\\"center-feed-posts\\">\\n            <h2>zipRev</h2>\\n            <p style=\\"margin-top:0.5%;margin-bottom:2%;font-size:12px;\\">Haskell; functional programming (9.25.24)</p>\\n            <p>A question- is it possible to reverse a functional list, then zip it with another list, in one pass?  In Haskell, a solution to this problem looks something like this:</p>\\n            <pre>zipRev = foldl f b\\n    where   b = const []\\n            f z x = \\\\case\\n                        [] -> []\\n                        (y:ys) -> (x,y) : z ys\\n            </pre>\\n            <p>Note that this requires the <code>LambdaCase</code> extension.</p>\\n            <p>&nbsp</p>\\n            <p>The function is a pretty elegant application of <code>foldl</code>, but I don't think its implementation is intuitively obvious - which begs the question of how one might come up with it from scratch.</p>\\n            <p>&nbsp</p>\\n            <p>Defining <code>zip</code> in terms of <code>foldr</code> and some folding function <code>g</code> is a potentially fruitful start, \\n            since <code>foldl (flip g)</code> can be loosely thought of as folding the first input list in \\"reverse\\".</p> \\n            <p>&nbsp</p>\\n            <p><code>zip = foldr g b</code> implies that <code>zip xs = foldr g b xs</code>.</p>\\n            <p>&nbsp</p>\\n            <p>Thus, <code>zip [] = b</code> by the definition of <code>foldr</code>, meaning that <code>b = \\\\ys -> []</code> or <code>const []</code> based on the semantics of <code>zip</code>.</p>\\n            <p>&nbsp</p>\\n            <p>At the same time, <code>zip (x:xs) = g x (foldr g b xs)</code>, meaning that <code>zip (x:xs) ys = g x (foldr g b xs) ys</code>.  </p>\\n            <p>&nbsp</p>\\n            <p>This tells us that our folding function <code>g</code> takes the head of <code>xs</code>, the result of folding its tail, and <code>ys</code> as arguments and returns a zipped list.  Remembering that\\n            folding its tail yields a function that zips its tail with whatever list you apply it to, we can straightforwardly define <code>g</code> as:</p>\\n            <pre>g x z = \\\\case\\n            [] -> []\\n            (y:ys) -> (x,y) : z ys\\n            </pre>\\n            <p>Now, <code>foldl (flip g) b</code> builds up a thunk such that the outermost application of <code>flip g</code> is partially applied to the last element of <code>xs</code>, \\n            before being applied to <code>ys</code>.  This is the behavior we want - the elements of <code>xs</code> are being paired up with the elements of <code>ys</code> in reverse order!</p>\\n            <p>&nbsp</p>\\n            <p>With this in mind, we can define <code>f = flip g</code> and <code>zipRev = foldl f b</code>.</p>\\n\\n        </div>\\n    </div>\\n</div>\\n\\n<style>\\n\\n@import url('https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@300..700&display=swap');\\n@import url('https://fonts.googleapis.com/css2?family=Manrope:wght@200..800&display=swap');\\n\\n.grid-container {\\n    position: fixed;\\n    top: 0;\\n    right: 0;\\n    height: 100vh;\\n    width: 100vw;\\n\\n    overflow: scroll;\\n    -webkit-overflow-scrolling: touch;\\n\\n    display: grid;\\n    grid-template-columns: repeat(9, 1fr);\\n}\\n\\n.center-feed {\\n    height: 100%;\\n    grid-column-start: 3;\\n    grid-column-end: 8;\\n}\\n\\n.center-feed-bar {\\n    z-index: 2;\\n    position: fixed;\\n    margin: 0;\\n    padding: 0;\\n    height: 180px;\\n    width: 100%;\\n    overflow: hidden;\\n    background: white;\\n}\\n\\n.center-feed-bar h1 {\\n    font-family: \\"Space Grotesk\\", sans-serif;\\n    position: relative;\\n    margin: 0;\\n    top: 120px;\\n    left: 200px;\\n    width: 500px;\\n}\\n\\n.center-feed h1{\\n    font-family: \\"Space Grotesk\\", sans-serif;\\n    z-index: 2;\\n    position: fixed;\\n    margin: 0;\\n    top: 130px;\\n    \\n}\\n\\n.center-feed-posts {\\n    position: relative;\\n    z-index: 1;\\n    top: 200px;\\n}\\n\\n.center-feed-posts h2 {\\n    margin: 0;\\n    font-family: \\"Manrope\\", sans-serif;\\n}\\n.center-feed-posts p {\\n    font-family: \\"Manrope\\", sans-serif;\\n    margin: 0;\\n}\\n\\n\\n\\n</style>\\n"],"names":[],"mappings":"AA+CA,QAAQ,wFAAwF,CAChG,QAAQ,kFAAkF,CAE1F,2CAAgB,CACZ,QAAQ,CAAE,KAAK,CACf,GAAG,CAAE,CAAC,CACN,KAAK,CAAE,CAAC,CACR,MAAM,CAAE,KAAK,CACb,KAAK,CAAE,KAAK,CAEZ,QAAQ,CAAE,MAAM,CAChB,0BAA0B,CAAE,KAAK,CAEjC,OAAO,CAAE,IAAI,CACb,qBAAqB,CAAE,OAAO,CAAC,CAAC,CAAC,GAAG,CACxC,CAEA,wCAAa,CACT,MAAM,CAAE,IAAI,CACZ,iBAAiB,CAAE,CAAC,CACpB,eAAe,CAAE,CACrB,CAEA,4CAAiB,CACb,OAAO,CAAE,CAAC,CACV,QAAQ,CAAE,KAAK,CACf,MAAM,CAAE,CAAC,CACT,OAAO,CAAE,CAAC,CACV,MAAM,CAAE,KAAK,CACb,KAAK,CAAE,IAAI,CACX,QAAQ,CAAE,MAAM,CAChB,UAAU,CAAE,KAChB,CAWA,0BAAY,CAAC,gBAAE,CACX,WAAW,CAAE,eAAe,CAAC,CAAC,UAAU,CACxC,OAAO,CAAE,CAAC,CACV,QAAQ,CAAE,KAAK,CACf,MAAM,CAAE,CAAC,CACT,GAAG,CAAE,KAET,CAEA,8CAAmB,CACf,QAAQ,CAAE,QAAQ,CAClB,OAAO,CAAE,CAAC,CACV,GAAG,CAAE,KACT,CAEA,gCAAkB,CAAC,gBAAG,CAClB,MAAM,CAAE,CAAC,CACT,WAAW,CAAE,SAAS,CAAC,CAAC,UAC5B,CACA,gCAAkB,CAAC,eAAE,CACjB,WAAW,CAAE,SAAS,CAAC,CAAC,UAAU,CAClC,MAAM,CAAE,CACZ"}`
};
const Page = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  $$result.css.add(css);
  return `<div class="grid-container svelte-77x811" data-svelte-h="svelte-e5s37"><div class="center-feed-bar svelte-77x811"></div> <div class="center-feed svelte-77x811"><h1 class="svelte-77x811">brodal queue
            <hr style="margin-top:3px;"></h1> <div class="center-feed-posts svelte-77x811"><h2 class="svelte-77x811">zipRev</h2> <p style="margin-top:0.5%;margin-bottom:2%;font-size:12px;" class="svelte-77x811">Haskell; functional programming (9.25.24)</p> <p class="svelte-77x811">A question- is it possible to reverse a functional list, then zip it with another list, in one pass?  In Haskell, a solution to this problem looks something like this:</p> <pre>zipRev = foldl f b
    where   b = const []
            f z x = \\case
                        [] -&gt; []
                        (y:ys) -&gt; (x,y) : z ys
            </pre> <p class="svelte-77x811">Note that this requires the <code>LambdaCase</code> extension.</p> <p class="svelte-77x811"> </p> <p class="svelte-77x811">The function is a pretty elegant application of <code>foldl</code>, but I don&#39;t think its implementation is intuitively obvious - which begs the question of how one might come up with it from scratch.</p> <p class="svelte-77x811"> </p> <p class="svelte-77x811">Defining <code>zip</code> in terms of <code>foldr</code> and some folding function <code>g</code> is a potentially fruitful start, 
            since <code>foldl (flip g)</code> can be loosely thought of as folding the first input list in &quot;reverse&quot;.</p> <p class="svelte-77x811"> </p> <p class="svelte-77x811"><code>zip = foldr g b</code> implies that <code>zip xs = foldr g b xs</code>.</p> <p class="svelte-77x811"> </p> <p class="svelte-77x811">Thus, <code>zip [] = b</code> by the definition of <code>foldr</code>, meaning that <code>b = \\ys -&gt; []</code> or <code>const []</code> based on the semantics of <code>zip</code>.</p> <p class="svelte-77x811"> </p> <p class="svelte-77x811">At the same time, <code>zip (x:xs) = g x (foldr g b xs)</code>, meaning that <code>zip (x:xs) ys = g x (foldr g b xs) ys</code>.</p> <p class="svelte-77x811"> </p> <p class="svelte-77x811">This tells us that our folding function <code>g</code> takes the head of <code>xs</code>, the result of folding its tail, and <code>ys</code> as arguments and returns a zipped list.  Remembering that
            folding its tail yields a function that zips its tail with whatever list you apply it to, we can straightforwardly define <code>g</code> as:</p> <pre>g x z = \\case
            [] -&gt; []
            (y:ys) -&gt; (x,y) : z ys
            </pre> <p class="svelte-77x811">Now, <code>foldl (flip g) b</code> builds up a thunk such that the outermost application of <code>flip g</code> is partially applied to the last element of <code>xs</code>, 
            before being applied to <code>ys</code>.  This is the behavior we want - the elements of <code>xs</code> are being paired up with the elements of <code>ys</code> in reverse order!</p> <p class="svelte-77x811"> </p> <p class="svelte-77x811">With this in mind, we can define <code>f = flip g</code> and <code>zipRev = foldl f b</code>.</p></div></div> </div>`;
});
export {
  Page as default
};
